// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/09/Square/Square.jack

/** Implements a graphical square. */
class Snake {
   field SnakeGame game;

   field int posX, posY;

   field int snakeLength;

   field int appleGrowth;

   field int toGrow;

   // 0=none, 1=up, 2=down, 3=left, 4=right
   field int direction, lastDirection;


   field Array histX, histY;
   field int histSize;


   constructor Snake new(SnakeGame Agame, int Ax, int Ay, int Alen, int Agrowby) {
      var int i;
      let game = Agame;
      let posX = Ax;
      let posY = Ay;
      let length = Alen;
      let growby = Agrowby;
      let togrow = 0;
      let direction = 4;
      let lastDirection = 4;
      let histSize = 512;
      let histX = Array.new(histSize);
      let histY = Array.new(histSize);

      // draw the initial snake
      let i = 0;
      while (i < length) {
         let posX = posX + 1;
         do drawHead(game.getCycle());
         let i = i + 1;
         do game.nextCycle();
      }

      return this;

   }

   method void dispose() {
      do histX.dispose();
      do histY.dispose();
      do Memory.deAlloc(this);
      return;
   }

   method boolean checkRewriteHistory() {
      if (game.getCycle() = histSize) {
         do rewriteHistory();
         return true;
      }
      return false;
   }

   method void rewriteHistory() {
      var int i, src, destination;
      let i = length;
      let destination = 0;
      let source = histSize - snakeLength;
      while (i > 0) {
         let histX[destination] = histX[source];
         let histY[destination] = histY[source];
         let source = source + 1;
         let destination = destination + 1;
         let i = i - 1;
      }
      return;
   }

   method int getPosX() {
      return posX;
   }

   method int getPosY() {
      return posY;
   }

   method int getLastDirection() {
      return lastDirection;
   }

   method void setDirectino(int newDirection) {
      let direction = newDirection;
      return;
   }

   method void rememberDirection() {
      let lastDirection = direction;
      return;
   }

   method boolean tryMove() {
      var SnakeGrid grid;
      
   }



   field int x, y; // screen location of the square's top-left corner
   field int size; // length of this square, in pixels

   /** Constructs a new square with a given location and size. */
   constructor Snake new(int Ax, int Ay, int Asize) {
      let x = Ax;
      let y = Ay;
      let size = Asize;
      do draw();
      return this;
   }

   /** Disposes this square. */
   method void dispose() {
      do Memory.deAlloc(this);
      return;
   }

   /** Draws the square on the screen. */
   method void draw() {
      do Screen.setColor(true);
      do drawRight(x, y);
      return;
   }

   method void drawRight(int x, int y) {
      var int memAddress;
      let memAddress = 16384 + getMemLocation(x, y);
      do Memory.poke(memAddress+0, 0);
      do Memory.poke(memAddress+32, 4096);
      do Memory.poke(memAddress+64, 16320);
      do Memory.poke(memAddress+96, 16368);
      do Memory.poke(memAddress+128, 16383);
      do Memory.poke(memAddress+160, 26623);
      do Memory.poke(memAddress+192, 25599);
      do Memory.poke(memAddress+224, 32767);
      do Memory.poke(memAddress+256, 32767);
      do Memory.poke(memAddress+288, 32767);
      do Memory.poke(memAddress+320, 32767);
      do Memory.poke(memAddress+352, 10239);
      do Memory.poke(memAddress+384, 2047);
      do Memory.poke(memAddress+416, 4095);
      do Memory.poke(memAddress+448, 32752);
      do Memory.poke(memAddress+480, 32736);
      return;
   }

   method void drawDown(int x, int y) {
      var int memAddress;
      let memAddress = 16384 + getMemLocation(x, y);
      do Memory.poke(memAddress+0, 4092);
      do Memory.poke(memAddress+32, 4092);
      do Memory.poke(memAddress+64, 4092);
      do Memory.poke(memAddress+96, 4092);
      do Memory.poke(memAddress+128, 8190);
      do Memory.poke(memAddress+160, 8191);
      do Memory.poke(memAddress+192, 16383);
      do Memory.poke(memAddress+224, 16383);
      do Memory.poke(memAddress+256, 16383);
      do Memory.poke(memAddress+288, 16383);
      do Memory.poke(memAddress+320, 15871);
      do Memory.poke(memAddress+352, 14823);
      do Memory.poke(memAddress+384, 31203);
      do Memory.poke(memAddress+416, 16371);
      do Memory.poke(memAddress+448, 2019);
      do Memory.poke(memAddress+480, 0);
      return;
   }

   method void drawLeft(int x, int y) {
      var int memAddress;
      let memAddress = 16384 + getMemLocation(x, y);
      do Memory.poke(memAddress+0, 0);
      do Memory.poke(memAddress+32, 8);
      do Memory.poke(memAddress+64, 1020);
      do Memory.poke(memAddress+96, 4092);
      do Memory.poke(memAddress+128, -4);
      do Memory.poke(memAddress+160, -26);
      do Memory.poke(memAddress+192, -58);
      do Memory.poke(memAddress+224, -2);
      do Memory.poke(memAddress+256, -2);
      do Memory.poke(memAddress+288, -2);
      do Memory.poke(memAddress+320, -2);
      do Memory.poke(memAddress+352, -28);
      do Memory.poke(memAddress+384, -32);
      do Memory.poke(memAddress+416, -16);
      do Memory.poke(memAddress+448, 4094);
      do Memory.poke(memAddress+480, 2046);
      return;
   }

   method void drawUp(int x, int y) {
      var int memAddress;
      let memAddress = 16384 + getMemLocation(x, y);
      do Memory.poke(memAddress+0, 0);
      do Memory.poke(memAddress+32, -14368);
      do Memory.poke(memAddress+64, -12292);
      do Memory.poke(memAddress+96, -14434);
      do Memory.poke(memAddress+128, -6244);
      do Memory.poke(memAddress+160, -68);
      do Memory.poke(memAddress+192, -4);
      do Memory.poke(memAddress+224, -4);
      do Memory.poke(memAddress+256, -4);
      do Memory.poke(memAddress+288, -4);
      do Memory.poke(memAddress+320, -8);
      do Memory.poke(memAddress+352, 32760);
      do Memory.poke(memAddress+384, 16368);
      do Memory.poke(memAddress+416, 16368);
      do Memory.poke(memAddress+448, 16368);
      do Memory.poke(memAddress+480, 16368);
      return;
   }

   /** Should be put in its own APPLE class!!
   draw 10 apples at initiation */
   method void drawApple(int x, int y) {
      var int memAddress;
      let memAddress = 16384 + getMemLocation(x, y);
      do Memory.poke(memAddress+0, 0);
      do Memory.poke(memAddress+32, 768);
      do Memory.poke(memAddress+64, 896);
      do Memory.poke(memAddress+96, 384);
      do Memory.poke(memAddress+128, 32764);
      do Memory.poke(memAddress+160, 32766);
      do Memory.poke(memAddress+192, 29694);
      do Memory.poke(memAddress+224, 30718);
      do Memory.poke(memAddress+256, 32766);
      do Memory.poke(memAddress+288, 32766);
      do Memory.poke(memAddress+320, 16380);
      do Memory.poke(memAddress+352, 16380);
      do Memory.poke(memAddress+384, 8184);
      do Memory.poke(memAddress+416, 4080);
      do Memory.poke(memAddress+448, 0);
      do Memory.poke(memAddress+480, 0);
      return;
   }

   method int getMemLocation(int x, int y) {
      var int location;
      let location = (32*y) + (x/16);
      return location;
   }

   /** Erases the square from the screen. */
   method void erase() {
      do Screen.setColor(false);
      do Screen.drawRectangle(x, y, x + size, y + size);
      return;
   }

    /** Increments the square size by 2 pixels. */
   method void incSize() {
      if (((y + size) < 254) & ((x + size) < 510)) {
         do erase();
         let size = size + 2;
         do draw();
      }
      return;
   }

   /** Decrements the square size by 2 pixels. */
   method void decSize() {
      if (size > 2) {
         do erase();
         let size = size - 2;
         do draw();
      }
      return;
   }

   /** Moves the square up by 2 pixels. */
   method void moveUp() {
      if (y > 1) {
         // i need to know direction, to know where to erase snake
         // first delete it by drawing it with background colour 
         do Screen.setColor(false);
         //do drawUp(x, y);
         do Screen.drawRectangle(x, (y + size) - 1, x + size, y + size);
         let y = y - 2;
         do Screen.setColor(true);
         do drawUp(x, y);
         //do Screen.drawRectangle(x, y, x + size, y + 1);
      }
      return;
   }

   /** Moves the square down by 2 pixels. */
   method void moveDown() {
      if ((y + size) < 254) {
         do Screen.setColor(false);
         do Screen.drawRectangle(x, y, x + size, y + 1);
         let y = y + 2;
         do Screen.setColor(true);
         do Screen.drawRectangle(x, (y + size) - 1, x + size, y + size);
      }
      return;
   }

   /** Moves the square left by 2 pixels. */
   method void moveLeft() {
      if (x > 1) {
         do Screen.setColor(false);
         do Screen.drawRectangle((x + size) - 1, y, x + size, y + size);
         let x = x - 2;
         do Screen.setColor(true);
         do Screen.drawRectangle(x, y, x + 1, y + size);
      }
      return;
   }

   /** Moves the square right by 2 pixels. */
   method void moveRight() {
      if ((x + size) < 510) {
         do Screen.setColor(false);
         do Screen.drawRectangle(x, y, x + 1, y + size);
         let x = x + 2;
         do Screen.setColor(true);
         do Screen.drawRectangle((x + size) - 1, y, x + size, y + size);
      }
      return;
   }
}
